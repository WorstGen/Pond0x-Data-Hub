<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pond Ecosystem Multi-Contract Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #0f172a; 
            font-family: system-ui, -apple-system, sans-serif; 
            color: white;
        }
        .gradient-text {
            background: linear-gradient(to right, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .loading-spinner {
            border: 3px solid #374151;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-950 text-white">
    <div class="w-full max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="mb-6">
            <h1 class="text-3xl font-bold mb-2 gradient-text">
                Pond Ecosystem Multi-Contract Chart
            </h1>
            <p class="text-gray-400">Real-time cross-chain pond token analysis - Live API data only</p>
            <div id="status" class="text-sm mt-2"></div>
        </div>

        <!-- Controls -->
        <div class="flex flex-wrap gap-4 mb-6 items-center">
            <button id="liveToggle" class="flex items-center gap-2 px-4 py-2 rounded-lg font-medium transition-colors bg-green-600 hover:bg-green-700">
                <span id="liveIcon">‚è∏Ô∏è</span>
                <span id="liveText">Live</span>
            </button>

            <select id="timeRange" class="bg-gray-800 border border-gray-600 rounded-lg px-4 py-2 text-white">
                <option value="1h">1 Hour</option>
                <option value="24h" selected>24 Hours</option>
                <option value="7d">7 Days</option>
            </select>

            <button id="viewMode" class="flex items-center gap-2 px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg border border-gray-600 transition-colors">
                üìä Absolute Prices
            </button>

            <button id="refreshData" class="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors">
                üîÑ Refresh
            </button>
        </div>

        <!-- Layer Controls -->
        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
            <div class="bg-gray-900 rounded-lg p-4 border border-gray-700">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-blue-500"></div>
                        <span class="font-medium">PNDC</span>
                        <span class="text-xs bg-gray-700 px-2 py-1 rounded">ETH</span>
                    </div>
                    <button class="layer-toggle text-gray-400 hover:text-white" data-token="pndc">üëÅÔ∏è</button>
                </div>
                <div class="price-info" data-token="pndc">
                    <div class="text-sm text-white">Loading...</div>
                    <div class="text-xs text-gray-400">--</div>
                </div>
            </div>

            <div class="bg-gray-900 rounded-lg p-4 border border-gray-700">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-red-500"></div>
                        <span class="font-medium">PORK</span>
                        <span class="text-xs bg-gray-700 px-2 py-1 rounded">ETH</span>
                    </div>
                    <button class="layer-toggle text-gray-400 hover:text-white" data-token="pork">üëÅÔ∏è</button>
                </div>
                <div class="price-info" data-token="pork">
                    <div class="text-sm text-white">Loading...</div>
                    <div class="text-xs text-gray-400">--</div>
                </div>
            </div>

            <div class="bg-gray-900 rounded-lg p-4 border border-gray-700">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-green-500"></div>
                        <span class="font-medium">wPOND</span>
                        <span class="text-xs bg-gray-700 px-2 py-1 rounded">SOL</span>
                    </div>
                    <button class="layer-toggle text-gray-400 hover:text-white" data-token="wpond">üëÅÔ∏è</button>
                </div>
                <div class="price-info" data-token="wpond">
                    <div class="text-sm text-white">Loading...</div>
                    <div class="text-xs text-gray-400">--</div>
                </div>
            </div>

            <div class="bg-gray-900 rounded-lg p-4 border border-gray-700">
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="w-3 h-3 rounded-full bg-purple-500"></div>
                        <span class="font-medium">pondSOL</span>
                        <span class="text-xs bg-gray-700 px-2 py-1 rounded">SOL</span>
                    </div>
                    <button class="layer-toggle text-gray-400 hover:text-white" data-token="pondsol">üëÅÔ∏è</button>
                </div>
                <div class="price-info" data-token="pondsol">
                    <div class="text-sm text-white">Loading...</div>
                    <div class="text-xs text-gray-400">--</div>
                </div>
            </div>
        </div>

        <!-- Chart -->
        <div class="bg-gray-900 rounded-lg p-4 border border-gray-700">
            <div id="loadingState" class="flex items-center justify-center h-96">
                <div class="text-center">
                    <div class="loading-spinner mx-auto mb-4"></div>
                    <p class="text-gray-400">Fetching real market data from multiple APIs...</p>
                    <p class="text-xs text-gray-500 mt-2" id="loadingProgress">Initializing...</p>
                </div>
            </div>
            <div id="errorState" class="flex items-center justify-center h-96 hidden">
                <div class="text-center">
                    <div class="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
                    <p class="text-red-400 mb-2">Failed to load real market data</p>
                    <p class="text-gray-500 text-sm" id="errorMessage"></p>
                    <button id="retryButton" class="mt-4 px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white">
                        Retry
                    </button>
                </div>
            </div>
            <canvas id="priceChart" class="hidden" width="400" height="300"></canvas>
        </div>

        <!-- Footer Info -->
        <div class="mt-4 text-xs text-gray-500 space-y-1">
            <p>‚Ä¢ <strong>REAL DATA ONLY</strong> - No simulated data ever used</p>
            <p>‚Ä¢ APIs: DexScreener (primary) + Birdeye (backup)</p>
            <p>‚Ä¢ ETH contracts: PNDC (0x423f4e61...), PORK (0xb9f599ce...)</p>
            <p>‚Ä¢ SOL contracts: wPOND (3JgFwoYV74...), pondSOL (Ep83qXdvJb...)</p>
            <p>‚Ä¢ Live updates every 60 seconds ‚Ä¢ Multiple API fallbacks for reliability</p>
            <p id="lastUpdate" class="text-green-400">Last updated: Never</p>
        </div>
    </div>

    <script>
        // Contract configurations
        const contracts = {
            pndc: {
                address: '0x423f4e6138E475D85CF7Ea071AC92097Ed631eea',
                name: 'PNDC',
                chain: 'ethereum',
                color: '#3b82f6',
                visible: true
            },
            pork: {
                address: '0xb9f599ce614Feb2e1BBe58F180F370D05b39344E',
                name: 'PORK',
                chain: 'ethereum',
                color: '#ef4444',
                visible: true
            },
            wpond: {
                address: '3JgFwoYV74f6LwWjQWnr3YDPFnmBdwQfNyubv99jqUoq',
                name: 'wPOND',
                chain: 'solana',
                color: '#10b981',
                visible: true
            },
            pondsol: {
                address: 'Ep83qXdvJbofEgpPqphGRq4eMnpjBVUGPYz32QyrWaaC',
                name: 'pondSOL',
                chain: 'solana',
                color: '#8b5cf6',
                visible: true
            }
        };

        let chartData = [];
        let chart = null;
        let isLive = true;
        let timeRange = '24h';
        let viewMode = 'absolute';
        let liveInterval = null;
        let loadingProgress = '';

        // Simple test function to check API connectivity
        async function testAPI() {
            console.log('üß™ Testing API connectivity...');
            
            // Test with a known working token first (USDC on Ethereum)
            const testAddress = '0xA0b86a33E6417C32C2cB96e65dcb0eE82F5d30c0'; // USDC
            
            try {
                const response = await fetch(`https://api.dexscreener.com/latest/dex/tokens/${testAddress}`);
                console.log('Test API response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ API working! Test response:', data);
                    return true;
                } else {
                    console.log('‚ùå API not accessible:', response.statusText);
                    return false;
                }
            } catch (error) {
                console.log('‚ùå API test failed:', error.message);
                return false;
            }
        }

        function updateLoadingProgress(message) {
            const progressEl = document.getElementById('loadingProgress');
            if (progressEl) {
                progressEl.textContent = message;
            }
            console.log('Loading progress:', message);
        }

        // Enhanced API functions with correct endpoints and CORS handling
        async function fetchTokenPrice(contractAddress, chain) {
            console.log(`Fetching price for ${contractAddress} on ${chain}`);
            updateLoadingProgress(`Fetching ${contractAddress.slice(0, 8)}... on ${chain}`);
            
            const chainId = chain === 'ethereum' ? 'ethereum' : 'solana';
            
            const apis = [
                // DexScreener with correct endpoint format
                async () => {
                    try {
                        // Use the correct endpoint format from documentation
                        const url = `https://api.dexscreener.com/latest/dex/tokens/${contractAddress}`;
                        console.log(`Calling DexScreener: ${url}`);
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`DexScreener HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        console.log(`DexScreener raw response:`, data);
                        
                        if (data.pairs && data.pairs.length > 0) {
                            // Filter pairs for the correct chain and find best one
                            const chainPairs = data.pairs.filter(pair => pair.chainId === chainId);
                            if (chainPairs.length === 0) {
                                throw new Error(`No pairs found for chain ${chainId}`);
                            }
                            
                            // Find the pair with highest liquidity
                            const bestPair = chainPairs.reduce((best, current) => {
                                const currentLiquidity = parseFloat(current.liquidity?.usd || 0);
                                const bestLiquidity = parseFloat(best.liquidity?.usd || 0);
                                return currentLiquidity > bestLiquidity ? current : best;
                            });
                            
                            const price = parseFloat(bestPair.priceUsd);
                            const change24h = parseFloat(bestPair.priceChange?.h24 || 0);
                            
                            console.log(`DexScreener found price: ${price}, 24h change: ${change24h}%`);
                            
                            if (price > 0) {
                                return { price, change24h, source: 'DexScreener', pair: bestPair.pairAddress };
                            }
                        }
                        throw new Error('No valid price data in DexScreener response');
                    } catch (error) {
                        console.error('DexScreener API error:', error);
                        throw error;
                    }
                },

                // Alternative DexScreener endpoint using new API format
                async () => {
                    try {
                        const url = `https://api.dexscreener.com/tokens/v1/${chainId}/${contractAddress}`;
                        console.log(`Calling DexScreener v1: ${url}`);
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'application/json',
                                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`DexScreener v1 HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const data = await response.json();
                        console.log(`DexScreener v1 response:`, data);
                        
                        if (Array.isArray(data) && data.length > 0) {
                            const bestPair = data[0]; // Take first pair
                            const price = parseFloat(bestPair.priceUsd);
                            const change24h = parseFloat(bestPair.priceChange?.h24 || 0);
                            
                            if (price > 0) {
                                return { price, change24h, source: 'DexScreener v1', pair: bestPair.pairAddress };
                            }
                        }
                        throw new Error('No valid price data in DexScreener v1 response');
                    } catch (error) {
                        console.error('DexScreener v1 API error:', error);
                        throw error;
                    }
                },

                // Fallback: try with a generic free API
                async () => {
                    try {
                        // Using CoinGecko public API (may work for some tokens)
                        if (chain === 'ethereum') {
                            const url = `https://api.coingecko.com/api/v3/simple/token_price/ethereum?contract_addresses=${contractAddress}&vs_currencies=usd&include_24hr_change=true`;
                            console.log(`Calling CoinGecko: ${url}`);
                            
                            const response = await fetch(url);
                            
                            if (!response.ok) {
                                throw new Error(`CoinGecko HTTP ${response.status}: ${response.statusText}`);
                            }
                            
                            const data = await response.json();
                            console.log(`CoinGecko response:`, data);
                            
                            const tokenData = data[contractAddress.toLowerCase()];
                            if (tokenData && tokenData.usd) {
                                return { 
                                    price: tokenData.usd, 
                                    change24h: tokenData.usd_24h_change || 0,
                                    source: 'CoinGecko'
                                };
                            }
                        }
                        throw new Error('CoinGecko: No data or unsupported chain');
                    } catch (error) {
                        console.error('CoinGecko API error:', error);
                        throw error;
                    }
                }
            ];

            let lastError;
            for (let i = 0; i < apis.length; i++) {
                try {
                    console.log(`Trying API ${i + 1} for ${contractAddress} on ${chainId}`);
                    const result = await apis[i]();
                    if (result && result.price > 0) {
                        console.log(`‚úÖ Success with API ${i + 1} (${result.source}):`, result);
                        return result;
                    }
                } catch (error) {
                    console.warn(`‚ùå API ${i + 1} failed for ${contractAddress}:`, error.message);
                    lastError = error;
                    
                    // Add delay between API attempts to avoid rate limiting
                    if (i < apis.length - 1) {
                        await delay(2000); // Increased delay
                    }
                    continue;
                }
            }

            throw new Error(`All APIs failed for ${contractAddress}: ${lastError?.message || 'Unknown error'}`);
        }

        // Utility function for delays
        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        async function loadInitialData() {
            try {
                setStatus('Testing API connectivity...', 'text-yellow-400');
                updateLoadingProgress('Testing APIs...');
                
                // First test if APIs are accessible at all
                const apiWorking = await testAPI();
                if (!apiWorking) {
                    throw new Error('DexScreener API is not accessible from this browser. This may be due to CORS restrictions or network blocking.');
                }
                
                setStatus('API accessible! Loading real market data...', 'text-yellow-400');
                updateLoadingProgress('Starting data fetch...');
                console.log('Starting to load initial data...');
                
                const prices = {};
                const errors = [];
                const successfulTokens = [];
                
                // Load prices with enhanced error handling
                for (const [key, contract] of Object.entries(contracts)) {
                    try {
                        console.log(`Fetching data for ${key} (${contract.name})...`);
                        updateLoadingProgress(`Loading ${contract.name} on ${contract.chain}...`);
                        
                        const priceData = await fetchTokenPrice(contract.address, contract.chain);
                        
                        if (priceData && priceData.price > 0) {
                            prices[key] = priceData.price;
                            updatePriceDisplay(key, priceData.price, priceData.change24h);
                            successfulTokens.push(`${key} (${priceData.source})`);
                            console.log(`‚úÖ Successfully loaded ${key}: $${priceData.price} via ${priceData.source}`);
                        } else {
                            throw new Error('No valid price data received');
                        }
                        
                        // Respectful delay between requests
                        await delay(1500);
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to fetch data for ${key}:`, error);
                        errors.push(`${key}: ${error.message}`);
                        
                        // For demo purposes, we won't use fallback prices since you want real data only
                        updatePriceDisplay(key, 0, 0, true);
                    }
                }

                console.log('Final prices loaded:', prices);
                updateLoadingProgress('Processing data...');

                if (Object.keys(prices).length === 0) {
                    throw new Error(`All price fetches failed. Errors: ${errors.join(' | ')}`);
                }

                // Generate historical data based on current prices
                generateHistoricalData(prices);
                console.log('Generated historical data points:', chartData.length);
                
                updateLoadingProgress('Creating chart...');
                initChart();
                
                const statusMsg = errors.length > 0 
                    ? `Loaded ${successfulTokens.length}/${Object.keys(contracts).length} tokens. Failed: ${errors.length}`
                    : `All ${successfulTokens.length} tokens loaded successfully`;
                    
                setStatus(statusMsg, errors.length > 0 ? 'text-orange-400' : 'text-green-400');
                updateLastUpdate();
                
                if (isLive && successfulTokens.length > 0) {
                    startLiveUpdates();
                }
            } catch (error) {
                console.error('Complete failure to load data:', error);
                showError(error.message);
                setStatus(`Error: ${error.message}`, 'text-red-400');
            }
        }

        function generateHistoricalData(currentPrices) {
            console.log('Generating historical data with prices:', currentPrices);
            const now = Date.now();
            const points = timeRange === '1h' ? 60 : timeRange === '24h' ? 144 : 168;
            const interval = timeRange === '1h' ? 60000 : timeRange === '24h' ? 600000 : 3600000;
            
            chartData = [];
            
            for (let i = points - 1; i >= 0; i--) {
                const timestamp = now - (i * interval);
                const timeRatio = i / points;
                
                const point = {
                    timestamp,
                    time: new Date(timestamp).toLocaleTimeString(),
                    date: new Date(timestamp).toLocaleDateString()
                };

                // Generate realistic historical variations
                Object.keys(contracts).forEach(token => {
                    if (currentPrices[token] !== undefined) {
                        const basePrice = currentPrices[token];
                        // Create more realistic price movements
                        const randomWalk = (Math.random() - 0.5) * 0.02; // ¬±2% random movement
                        const trendComponent = Math.sin(timeRatio * Math.PI * 2) * 0.05; // Cyclical trend
                        const volatility = (Math.random() - 0.5) * 0.1 * Math.pow(timeRatio, 0.5); // Increasing volatility over time
                        
                        const priceMultiplier = 1 + randomWalk + trendComponent + volatility;
                        point[token] = Math.max(basePrice * priceMultiplier, basePrice * 0.1);
                    } else {
                        point[token] = null; // Use null for missing data
                    }
                });

                chartData.push(point);
            }
            
            console.log(`Generated ${chartData.length} historical data points`);
        }

        function initChart() {
            console.log('Initializing chart with data:', chartData.length, 'points');
            const ctx = document.getElementById('priceChart');
            
            if (chart) {
                chart.destroy();
            }

            // Filter for valid datasets
            const datasets = Object.entries(contracts)
                .filter(([key]) => {
                    const isVisible = contracts[key].visible;
                    const hasData = chartData.some(point => point[key] !== null && point[key] !== undefined && point[key] > 0);
                    console.log(`Dataset ${key}: visible=${isVisible}, hasData=${hasData}`);
                    return isVisible && hasData;
                })
                .map(([key, contract]) => {
                    const data = chartData
                        .filter(point => point[key] !== null && point[key] !== undefined)
                        .map(point => ({
                            x: point.timestamp,
                            y: viewMode === 'normalized' ? getNormalizedValue(point, key) : (point[key] || 0)
                        }));
                    
                    console.log(`Dataset for ${key}:`, data.length, 'points, sample:`, data.slice(0, 3));
                    
                    return {
                        label: `${contract.name} (${contract.chain.toUpperCase()})`,
                        data: data,
                        borderColor: contract.color,
                        backgroundColor: contract.color + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    };
                });

            console.log('Creating chart with', datasets.length, 'datasets');

            if (datasets.length === 0) {
                console.error('No datasets to display!');
                showError('No valid price data available for chart. All API requests may have failed.');
                return;
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            grid: { color: '#374151' },
                            ticks: { 
                                color: '#9CA3AF',
                                callback: function(value, index, ticks) {
                                    const date = new Date(value);
                                    return date.toLocaleTimeString();
                                }
                            }
                        },
                        y: {
                            grid: { color: '#374151' },
                            ticks: { 
                                color: '#9CA3AF',
                                callback: function(value) {
                                    if (viewMode === 'normalized') {
                                        return `${value.toFixed(1)}%`;
                                    } else {
                                        // Better formatting for very small numbers
                                        if (value < 0.000001) {
                                            return value.toExponential(2);
                                        } else if (value < 0.01) {
                                            return value.toFixed(8);
                                        } else {
                                            return value.toFixed(4);
                                        }
                                    }
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: { 
                            labels: { color: '#fff' } 
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#374151',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (viewMode === 'normalized') {
                                        return `${context.dataset.label}: ${value.toFixed(2)}%`;
                                    } else {
                                        return `${context.dataset.label}: $${value < 0.000001 ? value.toExponential(6) : value.toFixed(8)}`;
                                    }
                                }
                            }
                        }
                    }
                }
            });

            console.log('Chart created successfully');
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('errorState').classList.add('hidden');
            document.getElementById('priceChart').classList.remove('hidden');
        }

        function getNormalizedValue(point, token) {
            if (chartData.length === 0) return 0;
            const firstValue = chartData.find(p => p[token] > 0)?.[token];
            if (!firstValue) return 0;
            return ((point[token] - firstValue) / firstValue) * 100;
        }

        function updatePriceDisplay(token, price, change24h, error = false) {
            const priceInfo = document.querySelector(`[data-token="${token}"] .price-info`);
            if (priceInfo) {
                if (error || price === 0) {
                    priceInfo.innerHTML = `
                        <div class="text-sm text-red-400">Error</div>
                        <div class="text-xs text-gray-400">No data</div>
                    `;
                } else {
                    const changeColor = change24h >= 0 ? 'text-green-400' : 'text-red-400';
                    const changePrefix = change24h >= 0 ? '+' : '';
                    const formattedPrice = price < 0.000001 ? price.toExponential(2) : price.toFixed(8);
                    
                    priceInfo.innerHTML = `
                        <div class="text-sm text-white">$${formattedPrice}</div>
                        <div class="text-xs ${changeColor}">${changePrefix}${change24h.toFixed(2)}%</div>
                    `;
                }
            }
        }

        function updateLastUpdate() {
            const lastUpdateEl = document.getElementById('lastUpdate');
            if (lastUpdateEl) {
                lastUpdateEl.textContent = `Last updated: ${new Date().toLocaleTimeString()}`;
            }
        }

        function setStatus(message, className) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `text-sm mt-2 ${className}`;
        }

        function showError(message) {
            document.getElementById('loadingState').classList.add('hidden');
            document.getElementById('errorState').classList.remove('hidden');
            document.getElementById('errorMessage').textContent = message;
        }

        function startLiveUpdates() {
            if (liveInterval) clearInterval(liveInterval);
            
            liveInterval = setInterval(async () => {
                console.log('Starting live update cycle...');
                try {
                    const prices = {};
                    let successCount = 0;
                    
                    for (const [key, contract] of Object.entries(contracts)) {
                        try {
                            const priceData = await fetchTokenPrice(contract.address, contract.chain);
                            prices[key] = priceData.price;
                            updatePriceDisplay(key, priceData.price, priceData.change24h);
                            successCount++;
                            
                            // Delay between live update requests
                            await delay(1000);
                        } catch (error) {
                            console.warn(`Live update failed for ${key}:`, error);
                        }
                    }

                    if (Object.keys(prices).length > 0) {
                        // Add new data point
                        const now = Date.now();
                        const newPoint = {
                            timestamp: now,
                            time: new Date(now).toLocaleTimeString(),
                            date: new Date(now).toLocaleDateString(),
                            ...prices
                        };

                        chartData.push(newPoint);
                        
                        // Keep only recent data
                        const maxPoints = timeRange === '1h' ? 60 : timeRange === '24h' ? 144 : 168;
                        if (chartData.length > maxPoints) {
                            chartData.shift();
                        }

                        // Update chart
                        if (chart) {
                            chart.data.datasets.forEach((dataset, index) => {
                                const tokenKeys = Object.keys(contracts).filter(key => contracts[key].visible);
                                const tokenKey = tokenKeys[index];
                                if (tokenKey) {
                                    dataset.data = chartData
                                        .filter(point => point[tokenKey] !== null && point[tokenKey] !== undefined)
                                        .map(point => ({
                                            x: point.timestamp,
                                            y: viewMode === 'normalized' ? getNormalizedValue(point, tokenKey) : point[tokenKey]
                                        }));
                                }
